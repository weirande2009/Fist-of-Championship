// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ServerToClient.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_ServerToClient_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_ServerToClient_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ServerToClient_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_ServerToClient_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_ServerToClient_2eproto;
namespace ChampionFist {
class AddFriendInfo;
struct AddFriendInfoDefaultTypeInternal;
extern AddFriendInfoDefaultTypeInternal _AddFriendInfo_default_instance_;
class FriendInfo;
struct FriendInfoDefaultTypeInternal;
extern FriendInfoDefaultTypeInternal _FriendInfo_default_instance_;
class PlayerInfo;
struct PlayerInfoDefaultTypeInternal;
extern PlayerInfoDefaultTypeInternal _PlayerInfo_default_instance_;
class RoomInfo;
struct RoomInfoDefaultTypeInternal;
extern RoomInfoDefaultTypeInternal _RoomInfo_default_instance_;
class S_AddFriend;
struct S_AddFriendDefaultTypeInternal;
extern S_AddFriendDefaultTypeInternal _S_AddFriend_default_instance_;
class S_CancelReady;
struct S_CancelReadyDefaultTypeInternal;
extern S_CancelReadyDefaultTypeInternal _S_CancelReady_default_instance_;
class S_CreateRoom;
struct S_CreateRoomDefaultTypeInternal;
extern S_CreateRoomDefaultTypeInternal _S_CreateRoom_default_instance_;
class S_EnterRoom;
struct S_EnterRoomDefaultTypeInternal;
extern S_EnterRoomDefaultTypeInternal _S_EnterRoom_default_instance_;
class S_ExitLogin;
struct S_ExitLoginDefaultTypeInternal;
extern S_ExitLoginDefaultTypeInternal _S_ExitLogin_default_instance_;
class S_ExitRoom;
struct S_ExitRoomDefaultTypeInternal;
extern S_ExitRoomDefaultTypeInternal _S_ExitRoom_default_instance_;
class S_Friend;
struct S_FriendDefaultTypeInternal;
extern S_FriendDefaultTypeInternal _S_Friend_default_instance_;
class S_FriendUpdate;
struct S_FriendUpdateDefaultTypeInternal;
extern S_FriendUpdateDefaultTypeInternal _S_FriendUpdate_default_instance_;
class S_HallRoom;
struct S_HallRoomDefaultTypeInternal;
extern S_HallRoomDefaultTypeInternal _S_HallRoom_default_instance_;
class S_Login;
struct S_LoginDefaultTypeInternal;
extern S_LoginDefaultTypeInternal _S_Login_default_instance_;
class S_ModChar;
struct S_ModCharDefaultTypeInternal;
extern S_ModCharDefaultTypeInternal _S_ModChar_default_instance_;
class S_OtherAddFriend;
struct S_OtherAddFriendDefaultTypeInternal;
extern S_OtherAddFriendDefaultTypeInternal _S_OtherAddFriend_default_instance_;
class S_Quit;
struct S_QuitDefaultTypeInternal;
extern S_QuitDefaultTypeInternal _S_Quit_default_instance_;
class S_Ready;
struct S_ReadyDefaultTypeInternal;
extern S_ReadyDefaultTypeInternal _S_Ready_default_instance_;
class S_Register;
struct S_RegisterDefaultTypeInternal;
extern S_RegisterDefaultTypeInternal _S_Register_default_instance_;
class S_RoomInfo;
struct S_RoomInfoDefaultTypeInternal;
extern S_RoomInfoDefaultTypeInternal _S_RoomInfo_default_instance_;
class S_StartGame;
struct S_StartGameDefaultTypeInternal;
extern S_StartGameDefaultTypeInternal _S_StartGame_default_instance_;
class S_UpdateRoom;
struct S_UpdateRoomDefaultTypeInternal;
extern S_UpdateRoomDefaultTypeInternal _S_UpdateRoom_default_instance_;
class SeatInfo;
struct SeatInfoDefaultTypeInternal;
extern SeatInfoDefaultTypeInternal _SeatInfo_default_instance_;
}  // namespace ChampionFist
PROTOBUF_NAMESPACE_OPEN
template<> ::ChampionFist::AddFriendInfo* Arena::CreateMaybeMessage<::ChampionFist::AddFriendInfo>(Arena*);
template<> ::ChampionFist::FriendInfo* Arena::CreateMaybeMessage<::ChampionFist::FriendInfo>(Arena*);
template<> ::ChampionFist::PlayerInfo* Arena::CreateMaybeMessage<::ChampionFist::PlayerInfo>(Arena*);
template<> ::ChampionFist::RoomInfo* Arena::CreateMaybeMessage<::ChampionFist::RoomInfo>(Arena*);
template<> ::ChampionFist::S_AddFriend* Arena::CreateMaybeMessage<::ChampionFist::S_AddFriend>(Arena*);
template<> ::ChampionFist::S_CancelReady* Arena::CreateMaybeMessage<::ChampionFist::S_CancelReady>(Arena*);
template<> ::ChampionFist::S_CreateRoom* Arena::CreateMaybeMessage<::ChampionFist::S_CreateRoom>(Arena*);
template<> ::ChampionFist::S_EnterRoom* Arena::CreateMaybeMessage<::ChampionFist::S_EnterRoom>(Arena*);
template<> ::ChampionFist::S_ExitLogin* Arena::CreateMaybeMessage<::ChampionFist::S_ExitLogin>(Arena*);
template<> ::ChampionFist::S_ExitRoom* Arena::CreateMaybeMessage<::ChampionFist::S_ExitRoom>(Arena*);
template<> ::ChampionFist::S_Friend* Arena::CreateMaybeMessage<::ChampionFist::S_Friend>(Arena*);
template<> ::ChampionFist::S_FriendUpdate* Arena::CreateMaybeMessage<::ChampionFist::S_FriendUpdate>(Arena*);
template<> ::ChampionFist::S_HallRoom* Arena::CreateMaybeMessage<::ChampionFist::S_HallRoom>(Arena*);
template<> ::ChampionFist::S_Login* Arena::CreateMaybeMessage<::ChampionFist::S_Login>(Arena*);
template<> ::ChampionFist::S_ModChar* Arena::CreateMaybeMessage<::ChampionFist::S_ModChar>(Arena*);
template<> ::ChampionFist::S_OtherAddFriend* Arena::CreateMaybeMessage<::ChampionFist::S_OtherAddFriend>(Arena*);
template<> ::ChampionFist::S_Quit* Arena::CreateMaybeMessage<::ChampionFist::S_Quit>(Arena*);
template<> ::ChampionFist::S_Ready* Arena::CreateMaybeMessage<::ChampionFist::S_Ready>(Arena*);
template<> ::ChampionFist::S_Register* Arena::CreateMaybeMessage<::ChampionFist::S_Register>(Arena*);
template<> ::ChampionFist::S_RoomInfo* Arena::CreateMaybeMessage<::ChampionFist::S_RoomInfo>(Arena*);
template<> ::ChampionFist::S_StartGame* Arena::CreateMaybeMessage<::ChampionFist::S_StartGame>(Arena*);
template<> ::ChampionFist::S_UpdateRoom* Arena::CreateMaybeMessage<::ChampionFist::S_UpdateRoom>(Arena*);
template<> ::ChampionFist::SeatInfo* Arena::CreateMaybeMessage<::ChampionFist::SeatInfo>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace ChampionFist {

enum ServerCommandType : int {
  S_EMPTY = 0,
  S_LOGIN = 1,
  S_REGISTER = 2,
  S_HALL_ROOM = 3,
  S_FRIEND = 4,
  S_FRIEND_UPDATE = 5,
  S_ENTER_ROOM = 6,
  S_ROOM_INFO = 7,
  S_EXIT_ROOM = 8,
  S_UPDATE_ROOM = 9,
  S_MODIFY_CHAR = 10,
  S_READY = 11,
  S_CANCEL_READY = 12,
  S_START_GAME = 13,
  S_EXIT_LOGIN = 14,
  S_QUIT = 15,
  S_ADD_FRIEND = 16,
  S_OTHER_ADD_FRIEND = 17,
  S_CREATE_ROOM = 18,
  ServerCommandType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  ServerCommandType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool ServerCommandType_IsValid(int value);
constexpr ServerCommandType ServerCommandType_MIN = S_EMPTY;
constexpr ServerCommandType ServerCommandType_MAX = S_CREATE_ROOM;
constexpr int ServerCommandType_ARRAYSIZE = ServerCommandType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ServerCommandType_descriptor();
template<typename T>
inline const std::string& ServerCommandType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ServerCommandType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ServerCommandType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ServerCommandType_descriptor(), enum_t_value);
}
inline bool ServerCommandType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ServerCommandType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ServerCommandType>(
    ServerCommandType_descriptor(), name, value);
}
// ===================================================================

class S_Login final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChampionFist.S_Login) */ {
 public:
  inline S_Login() : S_Login(nullptr) {}
  ~S_Login() override;
  explicit PROTOBUF_CONSTEXPR S_Login(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_Login(const S_Login& from);
  S_Login(S_Login&& from) noexcept
    : S_Login() {
    *this = ::std::move(from);
  }

  inline S_Login& operator=(const S_Login& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Login& operator=(S_Login&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Login& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Login* internal_default_instance() {
    return reinterpret_cast<const S_Login*>(
               &_S_Login_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(S_Login& a, S_Login& b) {
    a.Swap(&b);
  }
  inline void Swap(S_Login* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Login* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_Login* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_Login>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_Login& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_Login& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_Login* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChampionFist.S_Login";
  }
  protected:
  explicit S_Login(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
  };
  // int32 state = 1;
  void clear_state();
  int32_t state() const;
  void set_state(int32_t value);
  private:
  int32_t _internal_state() const;
  void _internal_set_state(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ChampionFist.S_Login)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ServerToClient_2eproto;
};
// -------------------------------------------------------------------

class S_Register final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChampionFist.S_Register) */ {
 public:
  inline S_Register() : S_Register(nullptr) {}
  ~S_Register() override;
  explicit PROTOBUF_CONSTEXPR S_Register(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_Register(const S_Register& from);
  S_Register(S_Register&& from) noexcept
    : S_Register() {
    *this = ::std::move(from);
  }

  inline S_Register& operator=(const S_Register& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Register& operator=(S_Register&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Register& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Register* internal_default_instance() {
    return reinterpret_cast<const S_Register*>(
               &_S_Register_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(S_Register& a, S_Register& b) {
    a.Swap(&b);
  }
  inline void Swap(S_Register* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Register* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_Register* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_Register>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_Register& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_Register& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_Register* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChampionFist.S_Register";
  }
  protected:
  explicit S_Register(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
  };
  // int32 state = 1;
  void clear_state();
  int32_t state() const;
  void set_state(int32_t value);
  private:
  int32_t _internal_state() const;
  void _internal_set_state(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ChampionFist.S_Register)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ServerToClient_2eproto;
};
// -------------------------------------------------------------------

class RoomInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChampionFist.RoomInfo) */ {
 public:
  inline RoomInfo() : RoomInfo(nullptr) {}
  ~RoomInfo() override;
  explicit PROTOBUF_CONSTEXPR RoomInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RoomInfo(const RoomInfo& from);
  RoomInfo(RoomInfo&& from) noexcept
    : RoomInfo() {
    *this = ::std::move(from);
  }

  inline RoomInfo& operator=(const RoomInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RoomInfo& operator=(RoomInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RoomInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const RoomInfo* internal_default_instance() {
    return reinterpret_cast<const RoomInfo*>(
               &_RoomInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(RoomInfo& a, RoomInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RoomInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RoomInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RoomInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RoomInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RoomInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RoomInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RoomInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChampionFist.RoomInfo";
  }
  protected:
  explicit RoomInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomNameFieldNumber = 2,
    kRoomNoFieldNumber = 3,
    kPlayerNumberFieldNumber = 1,
    kStateFieldNumber = 4,
  };
  // string room_name = 2;
  void clear_room_name();
  const std::string& room_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_room_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_room_name();
  PROTOBUF_NODISCARD std::string* release_room_name();
  void set_allocated_room_name(std::string* room_name);
  private:
  const std::string& _internal_room_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_room_name(const std::string& value);
  std::string* _internal_mutable_room_name();
  public:

  // string room_no = 3;
  void clear_room_no();
  const std::string& room_no() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_room_no(ArgT0&& arg0, ArgT... args);
  std::string* mutable_room_no();
  PROTOBUF_NODISCARD std::string* release_room_no();
  void set_allocated_room_no(std::string* room_no);
  private:
  const std::string& _internal_room_no() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_room_no(const std::string& value);
  std::string* _internal_mutable_room_no();
  public:

  // int32 player_number = 1;
  void clear_player_number();
  int32_t player_number() const;
  void set_player_number(int32_t value);
  private:
  int32_t _internal_player_number() const;
  void _internal_set_player_number(int32_t value);
  public:

  // int32 state = 4;
  void clear_state();
  int32_t state() const;
  void set_state(int32_t value);
  private:
  int32_t _internal_state() const;
  void _internal_set_state(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ChampionFist.RoomInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr room_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr room_no_;
  int32_t player_number_;
  int32_t state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ServerToClient_2eproto;
};
// -------------------------------------------------------------------

class S_HallRoom final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChampionFist.S_HallRoom) */ {
 public:
  inline S_HallRoom() : S_HallRoom(nullptr) {}
  ~S_HallRoom() override;
  explicit PROTOBUF_CONSTEXPR S_HallRoom(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_HallRoom(const S_HallRoom& from);
  S_HallRoom(S_HallRoom&& from) noexcept
    : S_HallRoom() {
    *this = ::std::move(from);
  }

  inline S_HallRoom& operator=(const S_HallRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_HallRoom& operator=(S_HallRoom&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_HallRoom& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_HallRoom* internal_default_instance() {
    return reinterpret_cast<const S_HallRoom*>(
               &_S_HallRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(S_HallRoom& a, S_HallRoom& b) {
    a.Swap(&b);
  }
  inline void Swap(S_HallRoom* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_HallRoom* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_HallRoom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_HallRoom>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_HallRoom& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_HallRoom& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_HallRoom* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChampionFist.S_HallRoom";
  }
  protected:
  explicit S_HallRoom(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRoomInfoFieldNumber = 3,
    kTotalRoomNumFieldNumber = 1,
    kPageRoomNumFieldNumber = 2,
  };
  // repeated .ChampionFist.RoomInfo room_info = 3;
  int room_info_size() const;
  private:
  int _internal_room_info_size() const;
  public:
  void clear_room_info();
  ::ChampionFist::RoomInfo* mutable_room_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ChampionFist::RoomInfo >*
      mutable_room_info();
  private:
  const ::ChampionFist::RoomInfo& _internal_room_info(int index) const;
  ::ChampionFist::RoomInfo* _internal_add_room_info();
  public:
  const ::ChampionFist::RoomInfo& room_info(int index) const;
  ::ChampionFist::RoomInfo* add_room_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ChampionFist::RoomInfo >&
      room_info() const;

  // int32 total_room_num = 1;
  void clear_total_room_num();
  int32_t total_room_num() const;
  void set_total_room_num(int32_t value);
  private:
  int32_t _internal_total_room_num() const;
  void _internal_set_total_room_num(int32_t value);
  public:

  // int32 page_room_num = 2;
  void clear_page_room_num();
  int32_t page_room_num() const;
  void set_page_room_num(int32_t value);
  private:
  int32_t _internal_page_room_num() const;
  void _internal_set_page_room_num(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ChampionFist.S_HallRoom)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ChampionFist::RoomInfo > room_info_;
  int32_t total_room_num_;
  int32_t page_room_num_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ServerToClient_2eproto;
};
// -------------------------------------------------------------------

class FriendInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChampionFist.FriendInfo) */ {
 public:
  inline FriendInfo() : FriendInfo(nullptr) {}
  ~FriendInfo() override;
  explicit PROTOBUF_CONSTEXPR FriendInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FriendInfo(const FriendInfo& from);
  FriendInfo(FriendInfo&& from) noexcept
    : FriendInfo() {
    *this = ::std::move(from);
  }

  inline FriendInfo& operator=(const FriendInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline FriendInfo& operator=(FriendInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FriendInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const FriendInfo* internal_default_instance() {
    return reinterpret_cast<const FriendInfo*>(
               &_FriendInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(FriendInfo& a, FriendInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(FriendInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FriendInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FriendInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FriendInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FriendInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FriendInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FriendInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChampionFist.FriendInfo";
  }
  protected:
  explicit FriendInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerNameFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  // string player_name = 1;
  void clear_player_name();
  const std::string& player_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_player_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_player_name();
  PROTOBUF_NODISCARD std::string* release_player_name();
  void set_allocated_player_name(std::string* player_name);
  private:
  const std::string& _internal_player_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_name(const std::string& value);
  std::string* _internal_mutable_player_name();
  public:

  // int32 state = 2;
  void clear_state();
  int32_t state() const;
  void set_state(int32_t value);
  private:
  int32_t _internal_state() const;
  void _internal_set_state(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ChampionFist.FriendInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr player_name_;
  int32_t state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ServerToClient_2eproto;
};
// -------------------------------------------------------------------

class S_Friend final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChampionFist.S_Friend) */ {
 public:
  inline S_Friend() : S_Friend(nullptr) {}
  ~S_Friend() override;
  explicit PROTOBUF_CONSTEXPR S_Friend(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_Friend(const S_Friend& from);
  S_Friend(S_Friend&& from) noexcept
    : S_Friend() {
    *this = ::std::move(from);
  }

  inline S_Friend& operator=(const S_Friend& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Friend& operator=(S_Friend&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Friend& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Friend* internal_default_instance() {
    return reinterpret_cast<const S_Friend*>(
               &_S_Friend_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(S_Friend& a, S_Friend& b) {
    a.Swap(&b);
  }
  inline void Swap(S_Friend* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Friend* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_Friend* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_Friend>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_Friend& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_Friend& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_Friend* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChampionFist.S_Friend";
  }
  protected:
  explicit S_Friend(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFriendInfoFieldNumber = 1,
  };
  // repeated .ChampionFist.FriendInfo friend_info = 1;
  int friend_info_size() const;
  private:
  int _internal_friend_info_size() const;
  public:
  void clear_friend_info();
  ::ChampionFist::FriendInfo* mutable_friend_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ChampionFist::FriendInfo >*
      mutable_friend_info();
  private:
  const ::ChampionFist::FriendInfo& _internal_friend_info(int index) const;
  ::ChampionFist::FriendInfo* _internal_add_friend_info();
  public:
  const ::ChampionFist::FriendInfo& friend_info(int index) const;
  ::ChampionFist::FriendInfo* add_friend_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ChampionFist::FriendInfo >&
      friend_info() const;

  // @@protoc_insertion_point(class_scope:ChampionFist.S_Friend)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ChampionFist::FriendInfo > friend_info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ServerToClient_2eproto;
};
// -------------------------------------------------------------------

class S_FriendUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChampionFist.S_FriendUpdate) */ {
 public:
  inline S_FriendUpdate() : S_FriendUpdate(nullptr) {}
  ~S_FriendUpdate() override;
  explicit PROTOBUF_CONSTEXPR S_FriendUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_FriendUpdate(const S_FriendUpdate& from);
  S_FriendUpdate(S_FriendUpdate&& from) noexcept
    : S_FriendUpdate() {
    *this = ::std::move(from);
  }

  inline S_FriendUpdate& operator=(const S_FriendUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_FriendUpdate& operator=(S_FriendUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_FriendUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_FriendUpdate* internal_default_instance() {
    return reinterpret_cast<const S_FriendUpdate*>(
               &_S_FriendUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(S_FriendUpdate& a, S_FriendUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(S_FriendUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_FriendUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_FriendUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_FriendUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_FriendUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_FriendUpdate& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_FriendUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChampionFist.S_FriendUpdate";
  }
  protected:
  explicit S_FriendUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFriendInfoFieldNumber = 1,
  };
  // .ChampionFist.FriendInfo friend_info = 1;
  bool has_friend_info() const;
  private:
  bool _internal_has_friend_info() const;
  public:
  void clear_friend_info();
  const ::ChampionFist::FriendInfo& friend_info() const;
  PROTOBUF_NODISCARD ::ChampionFist::FriendInfo* release_friend_info();
  ::ChampionFist::FriendInfo* mutable_friend_info();
  void set_allocated_friend_info(::ChampionFist::FriendInfo* friend_info);
  private:
  const ::ChampionFist::FriendInfo& _internal_friend_info() const;
  ::ChampionFist::FriendInfo* _internal_mutable_friend_info();
  public:
  void unsafe_arena_set_allocated_friend_info(
      ::ChampionFist::FriendInfo* friend_info);
  ::ChampionFist::FriendInfo* unsafe_arena_release_friend_info();

  // @@protoc_insertion_point(class_scope:ChampionFist.S_FriendUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::ChampionFist::FriendInfo* friend_info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ServerToClient_2eproto;
};
// -------------------------------------------------------------------

class S_EnterRoom final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChampionFist.S_EnterRoom) */ {
 public:
  inline S_EnterRoom() : S_EnterRoom(nullptr) {}
  ~S_EnterRoom() override;
  explicit PROTOBUF_CONSTEXPR S_EnterRoom(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_EnterRoom(const S_EnterRoom& from);
  S_EnterRoom(S_EnterRoom&& from) noexcept
    : S_EnterRoom() {
    *this = ::std::move(from);
  }

  inline S_EnterRoom& operator=(const S_EnterRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_EnterRoom& operator=(S_EnterRoom&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_EnterRoom& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_EnterRoom* internal_default_instance() {
    return reinterpret_cast<const S_EnterRoom*>(
               &_S_EnterRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(S_EnterRoom& a, S_EnterRoom& b) {
    a.Swap(&b);
  }
  inline void Swap(S_EnterRoom* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_EnterRoom* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_EnterRoom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_EnterRoom>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_EnterRoom& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_EnterRoom& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_EnterRoom* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChampionFist.S_EnterRoom";
  }
  protected:
  explicit S_EnterRoom(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSeatNoFieldNumber = 1,
    kStateFieldNumber = 2,
  };
  // int32 seat_no = 1;
  void clear_seat_no();
  int32_t seat_no() const;
  void set_seat_no(int32_t value);
  private:
  int32_t _internal_seat_no() const;
  void _internal_set_seat_no(int32_t value);
  public:

  // int32 state = 2;
  void clear_state();
  int32_t state() const;
  void set_state(int32_t value);
  private:
  int32_t _internal_state() const;
  void _internal_set_state(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ChampionFist.S_EnterRoom)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t seat_no_;
  int32_t state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ServerToClient_2eproto;
};
// -------------------------------------------------------------------

class PlayerInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChampionFist.PlayerInfo) */ {
 public:
  inline PlayerInfo() : PlayerInfo(nullptr) {}
  ~PlayerInfo() override;
  explicit PROTOBUF_CONSTEXPR PlayerInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PlayerInfo(const PlayerInfo& from);
  PlayerInfo(PlayerInfo&& from) noexcept
    : PlayerInfo() {
    *this = ::std::move(from);
  }

  inline PlayerInfo& operator=(const PlayerInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PlayerInfo& operator=(PlayerInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PlayerInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PlayerInfo* internal_default_instance() {
    return reinterpret_cast<const PlayerInfo*>(
               &_PlayerInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PlayerInfo& a, PlayerInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PlayerInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PlayerInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PlayerInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PlayerInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PlayerInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PlayerInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PlayerInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChampionFist.PlayerInfo";
  }
  protected:
  explicit PlayerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerNameFieldNumber = 1,
    kCharTypeFieldNumber = 2,
    kReadyFieldNumber = 3,
    kOwnerFieldNumber = 4,
  };
  // string player_name = 1;
  void clear_player_name();
  const std::string& player_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_player_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_player_name();
  PROTOBUF_NODISCARD std::string* release_player_name();
  void set_allocated_player_name(std::string* player_name);
  private:
  const std::string& _internal_player_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_player_name(const std::string& value);
  std::string* _internal_mutable_player_name();
  public:

  // int32 char_type = 2;
  void clear_char_type();
  int32_t char_type() const;
  void set_char_type(int32_t value);
  private:
  int32_t _internal_char_type() const;
  void _internal_set_char_type(int32_t value);
  public:

  // int32 ready = 3;
  void clear_ready();
  int32_t ready() const;
  void set_ready(int32_t value);
  private:
  int32_t _internal_ready() const;
  void _internal_set_ready(int32_t value);
  public:

  // int32 owner = 4;
  void clear_owner();
  int32_t owner() const;
  void set_owner(int32_t value);
  private:
  int32_t _internal_owner() const;
  void _internal_set_owner(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ChampionFist.PlayerInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr player_name_;
  int32_t char_type_;
  int32_t ready_;
  int32_t owner_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ServerToClient_2eproto;
};
// -------------------------------------------------------------------

class SeatInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChampionFist.SeatInfo) */ {
 public:
  inline SeatInfo() : SeatInfo(nullptr) {}
  ~SeatInfo() override;
  explicit PROTOBUF_CONSTEXPR SeatInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SeatInfo(const SeatInfo& from);
  SeatInfo(SeatInfo&& from) noexcept
    : SeatInfo() {
    *this = ::std::move(from);
  }

  inline SeatInfo& operator=(const SeatInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline SeatInfo& operator=(SeatInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SeatInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const SeatInfo* internal_default_instance() {
    return reinterpret_cast<const SeatInfo*>(
               &_SeatInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(SeatInfo& a, SeatInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(SeatInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SeatInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SeatInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SeatInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SeatInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SeatInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SeatInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChampionFist.SeatInfo";
  }
  protected:
  explicit SeatInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerInfoFieldNumber = 3,
    kEmptyFieldNumber = 1,
    kSeatNoFieldNumber = 2,
  };
  // .ChampionFist.PlayerInfo player_info = 3;
  bool has_player_info() const;
  private:
  bool _internal_has_player_info() const;
  public:
  void clear_player_info();
  const ::ChampionFist::PlayerInfo& player_info() const;
  PROTOBUF_NODISCARD ::ChampionFist::PlayerInfo* release_player_info();
  ::ChampionFist::PlayerInfo* mutable_player_info();
  void set_allocated_player_info(::ChampionFist::PlayerInfo* player_info);
  private:
  const ::ChampionFist::PlayerInfo& _internal_player_info() const;
  ::ChampionFist::PlayerInfo* _internal_mutable_player_info();
  public:
  void unsafe_arena_set_allocated_player_info(
      ::ChampionFist::PlayerInfo* player_info);
  ::ChampionFist::PlayerInfo* unsafe_arena_release_player_info();

  // int32 empty = 1;
  void clear_empty();
  int32_t empty() const;
  void set_empty(int32_t value);
  private:
  int32_t _internal_empty() const;
  void _internal_set_empty(int32_t value);
  public:

  // int32 seat_no = 2;
  void clear_seat_no();
  int32_t seat_no() const;
  void set_seat_no(int32_t value);
  private:
  int32_t _internal_seat_no() const;
  void _internal_set_seat_no(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ChampionFist.SeatInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::ChampionFist::PlayerInfo* player_info_;
  int32_t empty_;
  int32_t seat_no_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ServerToClient_2eproto;
};
// -------------------------------------------------------------------

class S_RoomInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChampionFist.S_RoomInfo) */ {
 public:
  inline S_RoomInfo() : S_RoomInfo(nullptr) {}
  ~S_RoomInfo() override;
  explicit PROTOBUF_CONSTEXPR S_RoomInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_RoomInfo(const S_RoomInfo& from);
  S_RoomInfo(S_RoomInfo&& from) noexcept
    : S_RoomInfo() {
    *this = ::std::move(from);
  }

  inline S_RoomInfo& operator=(const S_RoomInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_RoomInfo& operator=(S_RoomInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_RoomInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_RoomInfo* internal_default_instance() {
    return reinterpret_cast<const S_RoomInfo*>(
               &_S_RoomInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(S_RoomInfo& a, S_RoomInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(S_RoomInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_RoomInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_RoomInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_RoomInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_RoomInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_RoomInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_RoomInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChampionFist.S_RoomInfo";
  }
  protected:
  explicit S_RoomInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSeatInfoFieldNumber = 1,
  };
  // repeated .ChampionFist.SeatInfo seat_info = 1;
  int seat_info_size() const;
  private:
  int _internal_seat_info_size() const;
  public:
  void clear_seat_info();
  ::ChampionFist::SeatInfo* mutable_seat_info(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ChampionFist::SeatInfo >*
      mutable_seat_info();
  private:
  const ::ChampionFist::SeatInfo& _internal_seat_info(int index) const;
  ::ChampionFist::SeatInfo* _internal_add_seat_info();
  public:
  const ::ChampionFist::SeatInfo& seat_info(int index) const;
  ::ChampionFist::SeatInfo* add_seat_info();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ChampionFist::SeatInfo >&
      seat_info() const;

  // @@protoc_insertion_point(class_scope:ChampionFist.S_RoomInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ChampionFist::SeatInfo > seat_info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ServerToClient_2eproto;
};
// -------------------------------------------------------------------

class S_ExitRoom final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChampionFist.S_ExitRoom) */ {
 public:
  inline S_ExitRoom() : S_ExitRoom(nullptr) {}
  ~S_ExitRoom() override;
  explicit PROTOBUF_CONSTEXPR S_ExitRoom(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_ExitRoom(const S_ExitRoom& from);
  S_ExitRoom(S_ExitRoom&& from) noexcept
    : S_ExitRoom() {
    *this = ::std::move(from);
  }

  inline S_ExitRoom& operator=(const S_ExitRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_ExitRoom& operator=(S_ExitRoom&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_ExitRoom& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_ExitRoom* internal_default_instance() {
    return reinterpret_cast<const S_ExitRoom*>(
               &_S_ExitRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(S_ExitRoom& a, S_ExitRoom& b) {
    a.Swap(&b);
  }
  inline void Swap(S_ExitRoom* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_ExitRoom* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_ExitRoom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_ExitRoom>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_ExitRoom& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_ExitRoom& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_ExitRoom* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChampionFist.S_ExitRoom";
  }
  protected:
  explicit S_ExitRoom(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
  };
  // int32 state = 1;
  void clear_state();
  int32_t state() const;
  void set_state(int32_t value);
  private:
  int32_t _internal_state() const;
  void _internal_set_state(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ChampionFist.S_ExitRoom)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ServerToClient_2eproto;
};
// -------------------------------------------------------------------

class S_UpdateRoom final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChampionFist.S_UpdateRoom) */ {
 public:
  inline S_UpdateRoom() : S_UpdateRoom(nullptr) {}
  ~S_UpdateRoom() override;
  explicit PROTOBUF_CONSTEXPR S_UpdateRoom(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_UpdateRoom(const S_UpdateRoom& from);
  S_UpdateRoom(S_UpdateRoom&& from) noexcept
    : S_UpdateRoom() {
    *this = ::std::move(from);
  }

  inline S_UpdateRoom& operator=(const S_UpdateRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_UpdateRoom& operator=(S_UpdateRoom&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_UpdateRoom& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_UpdateRoom* internal_default_instance() {
    return reinterpret_cast<const S_UpdateRoom*>(
               &_S_UpdateRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(S_UpdateRoom& a, S_UpdateRoom& b) {
    a.Swap(&b);
  }
  inline void Swap(S_UpdateRoom* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_UpdateRoom* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_UpdateRoom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_UpdateRoom>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_UpdateRoom& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_UpdateRoom& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_UpdateRoom* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChampionFist.S_UpdateRoom";
  }
  protected:
  explicit S_UpdateRoom(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSeatInfoFieldNumber = 1,
  };
  // .ChampionFist.SeatInfo seat_info = 1;
  bool has_seat_info() const;
  private:
  bool _internal_has_seat_info() const;
  public:
  void clear_seat_info();
  const ::ChampionFist::SeatInfo& seat_info() const;
  PROTOBUF_NODISCARD ::ChampionFist::SeatInfo* release_seat_info();
  ::ChampionFist::SeatInfo* mutable_seat_info();
  void set_allocated_seat_info(::ChampionFist::SeatInfo* seat_info);
  private:
  const ::ChampionFist::SeatInfo& _internal_seat_info() const;
  ::ChampionFist::SeatInfo* _internal_mutable_seat_info();
  public:
  void unsafe_arena_set_allocated_seat_info(
      ::ChampionFist::SeatInfo* seat_info);
  ::ChampionFist::SeatInfo* unsafe_arena_release_seat_info();

  // @@protoc_insertion_point(class_scope:ChampionFist.S_UpdateRoom)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::ChampionFist::SeatInfo* seat_info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ServerToClient_2eproto;
};
// -------------------------------------------------------------------

class S_ModChar final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChampionFist.S_ModChar) */ {
 public:
  inline S_ModChar() : S_ModChar(nullptr) {}
  ~S_ModChar() override;
  explicit PROTOBUF_CONSTEXPR S_ModChar(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_ModChar(const S_ModChar& from);
  S_ModChar(S_ModChar&& from) noexcept
    : S_ModChar() {
    *this = ::std::move(from);
  }

  inline S_ModChar& operator=(const S_ModChar& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_ModChar& operator=(S_ModChar&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_ModChar& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_ModChar* internal_default_instance() {
    return reinterpret_cast<const S_ModChar*>(
               &_S_ModChar_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(S_ModChar& a, S_ModChar& b) {
    a.Swap(&b);
  }
  inline void Swap(S_ModChar* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_ModChar* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_ModChar* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_ModChar>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_ModChar& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_ModChar& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_ModChar* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChampionFist.S_ModChar";
  }
  protected:
  explicit S_ModChar(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
  };
  // int32 state = 1;
  void clear_state();
  int32_t state() const;
  void set_state(int32_t value);
  private:
  int32_t _internal_state() const;
  void _internal_set_state(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ChampionFist.S_ModChar)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ServerToClient_2eproto;
};
// -------------------------------------------------------------------

class S_Ready final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChampionFist.S_Ready) */ {
 public:
  inline S_Ready() : S_Ready(nullptr) {}
  ~S_Ready() override;
  explicit PROTOBUF_CONSTEXPR S_Ready(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_Ready(const S_Ready& from);
  S_Ready(S_Ready&& from) noexcept
    : S_Ready() {
    *this = ::std::move(from);
  }

  inline S_Ready& operator=(const S_Ready& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Ready& operator=(S_Ready&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Ready& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Ready* internal_default_instance() {
    return reinterpret_cast<const S_Ready*>(
               &_S_Ready_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(S_Ready& a, S_Ready& b) {
    a.Swap(&b);
  }
  inline void Swap(S_Ready* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Ready* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_Ready* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_Ready>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_Ready& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_Ready& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_Ready* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChampionFist.S_Ready";
  }
  protected:
  explicit S_Ready(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
  };
  // int32 state = 1;
  void clear_state();
  int32_t state() const;
  void set_state(int32_t value);
  private:
  int32_t _internal_state() const;
  void _internal_set_state(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ChampionFist.S_Ready)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ServerToClient_2eproto;
};
// -------------------------------------------------------------------

class S_CancelReady final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChampionFist.S_CancelReady) */ {
 public:
  inline S_CancelReady() : S_CancelReady(nullptr) {}
  ~S_CancelReady() override;
  explicit PROTOBUF_CONSTEXPR S_CancelReady(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_CancelReady(const S_CancelReady& from);
  S_CancelReady(S_CancelReady&& from) noexcept
    : S_CancelReady() {
    *this = ::std::move(from);
  }

  inline S_CancelReady& operator=(const S_CancelReady& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_CancelReady& operator=(S_CancelReady&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_CancelReady& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_CancelReady* internal_default_instance() {
    return reinterpret_cast<const S_CancelReady*>(
               &_S_CancelReady_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(S_CancelReady& a, S_CancelReady& b) {
    a.Swap(&b);
  }
  inline void Swap(S_CancelReady* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_CancelReady* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_CancelReady* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_CancelReady>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_CancelReady& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_CancelReady& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_CancelReady* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChampionFist.S_CancelReady";
  }
  protected:
  explicit S_CancelReady(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
  };
  // int32 state = 1;
  void clear_state();
  int32_t state() const;
  void set_state(int32_t value);
  private:
  int32_t _internal_state() const;
  void _internal_set_state(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ChampionFist.S_CancelReady)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ServerToClient_2eproto;
};
// -------------------------------------------------------------------

class S_StartGame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChampionFist.S_StartGame) */ {
 public:
  inline S_StartGame() : S_StartGame(nullptr) {}
  ~S_StartGame() override;
  explicit PROTOBUF_CONSTEXPR S_StartGame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_StartGame(const S_StartGame& from);
  S_StartGame(S_StartGame&& from) noexcept
    : S_StartGame() {
    *this = ::std::move(from);
  }

  inline S_StartGame& operator=(const S_StartGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_StartGame& operator=(S_StartGame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_StartGame& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_StartGame* internal_default_instance() {
    return reinterpret_cast<const S_StartGame*>(
               &_S_StartGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(S_StartGame& a, S_StartGame& b) {
    a.Swap(&b);
  }
  inline void Swap(S_StartGame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_StartGame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_StartGame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_StartGame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_StartGame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_StartGame& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_StartGame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChampionFist.S_StartGame";
  }
  protected:
  explicit S_StartGame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
  };
  // int32 state = 1;
  void clear_state();
  int32_t state() const;
  void set_state(int32_t value);
  private:
  int32_t _internal_state() const;
  void _internal_set_state(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ChampionFist.S_StartGame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ServerToClient_2eproto;
};
// -------------------------------------------------------------------

class S_ExitLogin final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChampionFist.S_ExitLogin) */ {
 public:
  inline S_ExitLogin() : S_ExitLogin(nullptr) {}
  ~S_ExitLogin() override;
  explicit PROTOBUF_CONSTEXPR S_ExitLogin(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_ExitLogin(const S_ExitLogin& from);
  S_ExitLogin(S_ExitLogin&& from) noexcept
    : S_ExitLogin() {
    *this = ::std::move(from);
  }

  inline S_ExitLogin& operator=(const S_ExitLogin& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_ExitLogin& operator=(S_ExitLogin&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_ExitLogin& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_ExitLogin* internal_default_instance() {
    return reinterpret_cast<const S_ExitLogin*>(
               &_S_ExitLogin_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(S_ExitLogin& a, S_ExitLogin& b) {
    a.Swap(&b);
  }
  inline void Swap(S_ExitLogin* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_ExitLogin* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_ExitLogin* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_ExitLogin>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_ExitLogin& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_ExitLogin& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_ExitLogin* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChampionFist.S_ExitLogin";
  }
  protected:
  explicit S_ExitLogin(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
  };
  // int32 state = 1;
  void clear_state();
  int32_t state() const;
  void set_state(int32_t value);
  private:
  int32_t _internal_state() const;
  void _internal_set_state(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ChampionFist.S_ExitLogin)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ServerToClient_2eproto;
};
// -------------------------------------------------------------------

class S_Quit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChampionFist.S_Quit) */ {
 public:
  inline S_Quit() : S_Quit(nullptr) {}
  ~S_Quit() override;
  explicit PROTOBUF_CONSTEXPR S_Quit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_Quit(const S_Quit& from);
  S_Quit(S_Quit&& from) noexcept
    : S_Quit() {
    *this = ::std::move(from);
  }

  inline S_Quit& operator=(const S_Quit& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_Quit& operator=(S_Quit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_Quit& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_Quit* internal_default_instance() {
    return reinterpret_cast<const S_Quit*>(
               &_S_Quit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(S_Quit& a, S_Quit& b) {
    a.Swap(&b);
  }
  inline void Swap(S_Quit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_Quit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_Quit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_Quit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_Quit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_Quit& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_Quit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChampionFist.S_Quit";
  }
  protected:
  explicit S_Quit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
  };
  // int32 state = 1;
  void clear_state();
  int32_t state() const;
  void set_state(int32_t value);
  private:
  int32_t _internal_state() const;
  void _internal_set_state(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ChampionFist.S_Quit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ServerToClient_2eproto;
};
// -------------------------------------------------------------------

class S_AddFriend final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChampionFist.S_AddFriend) */ {
 public:
  inline S_AddFriend() : S_AddFriend(nullptr) {}
  ~S_AddFriend() override;
  explicit PROTOBUF_CONSTEXPR S_AddFriend(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_AddFriend(const S_AddFriend& from);
  S_AddFriend(S_AddFriend&& from) noexcept
    : S_AddFriend() {
    *this = ::std::move(from);
  }

  inline S_AddFriend& operator=(const S_AddFriend& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_AddFriend& operator=(S_AddFriend&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_AddFriend& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_AddFriend* internal_default_instance() {
    return reinterpret_cast<const S_AddFriend*>(
               &_S_AddFriend_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(S_AddFriend& a, S_AddFriend& b) {
    a.Swap(&b);
  }
  inline void Swap(S_AddFriend* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_AddFriend* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_AddFriend* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_AddFriend>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_AddFriend& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_AddFriend& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_AddFriend* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChampionFist.S_AddFriend";
  }
  protected:
  explicit S_AddFriend(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
  };
  // int32 state = 1;
  void clear_state();
  int32_t state() const;
  void set_state(int32_t value);
  private:
  int32_t _internal_state() const;
  void _internal_set_state(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ChampionFist.S_AddFriend)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ServerToClient_2eproto;
};
// -------------------------------------------------------------------

class AddFriendInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChampionFist.AddFriendInfo) */ {
 public:
  inline AddFriendInfo() : AddFriendInfo(nullptr) {}
  ~AddFriendInfo() override;
  explicit PROTOBUF_CONSTEXPR AddFriendInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddFriendInfo(const AddFriendInfo& from);
  AddFriendInfo(AddFriendInfo&& from) noexcept
    : AddFriendInfo() {
    *this = ::std::move(from);
  }

  inline AddFriendInfo& operator=(const AddFriendInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddFriendInfo& operator=(AddFriendInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddFriendInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddFriendInfo* internal_default_instance() {
    return reinterpret_cast<const AddFriendInfo*>(
               &_AddFriendInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(AddFriendInfo& a, AddFriendInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(AddFriendInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddFriendInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddFriendInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddFriendInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddFriendInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AddFriendInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddFriendInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChampionFist.AddFriendInfo";
  }
  protected:
  explicit AddFriendInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFriendNameFieldNumber = 1,
  };
  // string friend_name = 1;
  void clear_friend_name();
  const std::string& friend_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_friend_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_friend_name();
  PROTOBUF_NODISCARD std::string* release_friend_name();
  void set_allocated_friend_name(std::string* friend_name);
  private:
  const std::string& _internal_friend_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_friend_name(const std::string& value);
  std::string* _internal_mutable_friend_name();
  public:

  // @@protoc_insertion_point(class_scope:ChampionFist.AddFriendInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr friend_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ServerToClient_2eproto;
};
// -------------------------------------------------------------------

class S_OtherAddFriend final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChampionFist.S_OtherAddFriend) */ {
 public:
  inline S_OtherAddFriend() : S_OtherAddFriend(nullptr) {}
  ~S_OtherAddFriend() override;
  explicit PROTOBUF_CONSTEXPR S_OtherAddFriend(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_OtherAddFriend(const S_OtherAddFriend& from);
  S_OtherAddFriend(S_OtherAddFriend&& from) noexcept
    : S_OtherAddFriend() {
    *this = ::std::move(from);
  }

  inline S_OtherAddFriend& operator=(const S_OtherAddFriend& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_OtherAddFriend& operator=(S_OtherAddFriend&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_OtherAddFriend& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_OtherAddFriend* internal_default_instance() {
    return reinterpret_cast<const S_OtherAddFriend*>(
               &_S_OtherAddFriend_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(S_OtherAddFriend& a, S_OtherAddFriend& b) {
    a.Swap(&b);
  }
  inline void Swap(S_OtherAddFriend* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_OtherAddFriend* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_OtherAddFriend* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_OtherAddFriend>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_OtherAddFriend& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_OtherAddFriend& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_OtherAddFriend* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChampionFist.S_OtherAddFriend";
  }
  protected:
  explicit S_OtherAddFriend(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFriendInfoFieldNumber = 1,
  };
  // .ChampionFist.AddFriendInfo friend_info = 1;
  bool has_friend_info() const;
  private:
  bool _internal_has_friend_info() const;
  public:
  void clear_friend_info();
  const ::ChampionFist::AddFriendInfo& friend_info() const;
  PROTOBUF_NODISCARD ::ChampionFist::AddFriendInfo* release_friend_info();
  ::ChampionFist::AddFriendInfo* mutable_friend_info();
  void set_allocated_friend_info(::ChampionFist::AddFriendInfo* friend_info);
  private:
  const ::ChampionFist::AddFriendInfo& _internal_friend_info() const;
  ::ChampionFist::AddFriendInfo* _internal_mutable_friend_info();
  public:
  void unsafe_arena_set_allocated_friend_info(
      ::ChampionFist::AddFriendInfo* friend_info);
  ::ChampionFist::AddFriendInfo* unsafe_arena_release_friend_info();

  // @@protoc_insertion_point(class_scope:ChampionFist.S_OtherAddFriend)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::ChampionFist::AddFriendInfo* friend_info_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ServerToClient_2eproto;
};
// -------------------------------------------------------------------

class S_CreateRoom final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:ChampionFist.S_CreateRoom) */ {
 public:
  inline S_CreateRoom() : S_CreateRoom(nullptr) {}
  ~S_CreateRoom() override;
  explicit PROTOBUF_CONSTEXPR S_CreateRoom(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  S_CreateRoom(const S_CreateRoom& from);
  S_CreateRoom(S_CreateRoom&& from) noexcept
    : S_CreateRoom() {
    *this = ::std::move(from);
  }

  inline S_CreateRoom& operator=(const S_CreateRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline S_CreateRoom& operator=(S_CreateRoom&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const S_CreateRoom& default_instance() {
    return *internal_default_instance();
  }
  static inline const S_CreateRoom* internal_default_instance() {
    return reinterpret_cast<const S_CreateRoom*>(
               &_S_CreateRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(S_CreateRoom& a, S_CreateRoom& b) {
    a.Swap(&b);
  }
  inline void Swap(S_CreateRoom* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(S_CreateRoom* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  S_CreateRoom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<S_CreateRoom>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const S_CreateRoom& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const S_CreateRoom& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(S_CreateRoom* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "ChampionFist.S_CreateRoom";
  }
  protected:
  explicit S_CreateRoom(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStateFieldNumber = 1,
  };
  // int32 state = 1;
  void clear_state();
  int32_t state() const;
  void set_state(int32_t value);
  private:
  int32_t _internal_state() const;
  void _internal_set_state(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:ChampionFist.S_CreateRoom)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_ServerToClient_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// S_Login

// int32 state = 1;
inline void S_Login::clear_state() {
  state_ = 0;
}
inline int32_t S_Login::_internal_state() const {
  return state_;
}
inline int32_t S_Login::state() const {
  // @@protoc_insertion_point(field_get:ChampionFist.S_Login.state)
  return _internal_state();
}
inline void S_Login::_internal_set_state(int32_t value) {
  
  state_ = value;
}
inline void S_Login::set_state(int32_t value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:ChampionFist.S_Login.state)
}

// -------------------------------------------------------------------

// S_Register

// int32 state = 1;
inline void S_Register::clear_state() {
  state_ = 0;
}
inline int32_t S_Register::_internal_state() const {
  return state_;
}
inline int32_t S_Register::state() const {
  // @@protoc_insertion_point(field_get:ChampionFist.S_Register.state)
  return _internal_state();
}
inline void S_Register::_internal_set_state(int32_t value) {
  
  state_ = value;
}
inline void S_Register::set_state(int32_t value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:ChampionFist.S_Register.state)
}

// -------------------------------------------------------------------

// RoomInfo

// int32 player_number = 1;
inline void RoomInfo::clear_player_number() {
  player_number_ = 0;
}
inline int32_t RoomInfo::_internal_player_number() const {
  return player_number_;
}
inline int32_t RoomInfo::player_number() const {
  // @@protoc_insertion_point(field_get:ChampionFist.RoomInfo.player_number)
  return _internal_player_number();
}
inline void RoomInfo::_internal_set_player_number(int32_t value) {
  
  player_number_ = value;
}
inline void RoomInfo::set_player_number(int32_t value) {
  _internal_set_player_number(value);
  // @@protoc_insertion_point(field_set:ChampionFist.RoomInfo.player_number)
}

// string room_name = 2;
inline void RoomInfo::clear_room_name() {
  room_name_.ClearToEmpty();
}
inline const std::string& RoomInfo::room_name() const {
  // @@protoc_insertion_point(field_get:ChampionFist.RoomInfo.room_name)
  return _internal_room_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoomInfo::set_room_name(ArgT0&& arg0, ArgT... args) {
 
 room_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ChampionFist.RoomInfo.room_name)
}
inline std::string* RoomInfo::mutable_room_name() {
  std::string* _s = _internal_mutable_room_name();
  // @@protoc_insertion_point(field_mutable:ChampionFist.RoomInfo.room_name)
  return _s;
}
inline const std::string& RoomInfo::_internal_room_name() const {
  return room_name_.Get();
}
inline void RoomInfo::_internal_set_room_name(const std::string& value) {
  
  room_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RoomInfo::_internal_mutable_room_name() {
  
  return room_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RoomInfo::release_room_name() {
  // @@protoc_insertion_point(field_release:ChampionFist.RoomInfo.room_name)
  return room_name_.Release();
}
inline void RoomInfo::set_allocated_room_name(std::string* room_name) {
  if (room_name != nullptr) {
    
  } else {
    
  }
  room_name_.SetAllocated(room_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (room_name_.IsDefault()) {
    room_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ChampionFist.RoomInfo.room_name)
}

// string room_no = 3;
inline void RoomInfo::clear_room_no() {
  room_no_.ClearToEmpty();
}
inline const std::string& RoomInfo::room_no() const {
  // @@protoc_insertion_point(field_get:ChampionFist.RoomInfo.room_no)
  return _internal_room_no();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RoomInfo::set_room_no(ArgT0&& arg0, ArgT... args) {
 
 room_no_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ChampionFist.RoomInfo.room_no)
}
inline std::string* RoomInfo::mutable_room_no() {
  std::string* _s = _internal_mutable_room_no();
  // @@protoc_insertion_point(field_mutable:ChampionFist.RoomInfo.room_no)
  return _s;
}
inline const std::string& RoomInfo::_internal_room_no() const {
  return room_no_.Get();
}
inline void RoomInfo::_internal_set_room_no(const std::string& value) {
  
  room_no_.Set(value, GetArenaForAllocation());
}
inline std::string* RoomInfo::_internal_mutable_room_no() {
  
  return room_no_.Mutable(GetArenaForAllocation());
}
inline std::string* RoomInfo::release_room_no() {
  // @@protoc_insertion_point(field_release:ChampionFist.RoomInfo.room_no)
  return room_no_.Release();
}
inline void RoomInfo::set_allocated_room_no(std::string* room_no) {
  if (room_no != nullptr) {
    
  } else {
    
  }
  room_no_.SetAllocated(room_no, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (room_no_.IsDefault()) {
    room_no_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ChampionFist.RoomInfo.room_no)
}

// int32 state = 4;
inline void RoomInfo::clear_state() {
  state_ = 0;
}
inline int32_t RoomInfo::_internal_state() const {
  return state_;
}
inline int32_t RoomInfo::state() const {
  // @@protoc_insertion_point(field_get:ChampionFist.RoomInfo.state)
  return _internal_state();
}
inline void RoomInfo::_internal_set_state(int32_t value) {
  
  state_ = value;
}
inline void RoomInfo::set_state(int32_t value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:ChampionFist.RoomInfo.state)
}

// -------------------------------------------------------------------

// S_HallRoom

// int32 total_room_num = 1;
inline void S_HallRoom::clear_total_room_num() {
  total_room_num_ = 0;
}
inline int32_t S_HallRoom::_internal_total_room_num() const {
  return total_room_num_;
}
inline int32_t S_HallRoom::total_room_num() const {
  // @@protoc_insertion_point(field_get:ChampionFist.S_HallRoom.total_room_num)
  return _internal_total_room_num();
}
inline void S_HallRoom::_internal_set_total_room_num(int32_t value) {
  
  total_room_num_ = value;
}
inline void S_HallRoom::set_total_room_num(int32_t value) {
  _internal_set_total_room_num(value);
  // @@protoc_insertion_point(field_set:ChampionFist.S_HallRoom.total_room_num)
}

// int32 page_room_num = 2;
inline void S_HallRoom::clear_page_room_num() {
  page_room_num_ = 0;
}
inline int32_t S_HallRoom::_internal_page_room_num() const {
  return page_room_num_;
}
inline int32_t S_HallRoom::page_room_num() const {
  // @@protoc_insertion_point(field_get:ChampionFist.S_HallRoom.page_room_num)
  return _internal_page_room_num();
}
inline void S_HallRoom::_internal_set_page_room_num(int32_t value) {
  
  page_room_num_ = value;
}
inline void S_HallRoom::set_page_room_num(int32_t value) {
  _internal_set_page_room_num(value);
  // @@protoc_insertion_point(field_set:ChampionFist.S_HallRoom.page_room_num)
}

// repeated .ChampionFist.RoomInfo room_info = 3;
inline int S_HallRoom::_internal_room_info_size() const {
  return room_info_.size();
}
inline int S_HallRoom::room_info_size() const {
  return _internal_room_info_size();
}
inline void S_HallRoom::clear_room_info() {
  room_info_.Clear();
}
inline ::ChampionFist::RoomInfo* S_HallRoom::mutable_room_info(int index) {
  // @@protoc_insertion_point(field_mutable:ChampionFist.S_HallRoom.room_info)
  return room_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ChampionFist::RoomInfo >*
S_HallRoom::mutable_room_info() {
  // @@protoc_insertion_point(field_mutable_list:ChampionFist.S_HallRoom.room_info)
  return &room_info_;
}
inline const ::ChampionFist::RoomInfo& S_HallRoom::_internal_room_info(int index) const {
  return room_info_.Get(index);
}
inline const ::ChampionFist::RoomInfo& S_HallRoom::room_info(int index) const {
  // @@protoc_insertion_point(field_get:ChampionFist.S_HallRoom.room_info)
  return _internal_room_info(index);
}
inline ::ChampionFist::RoomInfo* S_HallRoom::_internal_add_room_info() {
  return room_info_.Add();
}
inline ::ChampionFist::RoomInfo* S_HallRoom::add_room_info() {
  ::ChampionFist::RoomInfo* _add = _internal_add_room_info();
  // @@protoc_insertion_point(field_add:ChampionFist.S_HallRoom.room_info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ChampionFist::RoomInfo >&
S_HallRoom::room_info() const {
  // @@protoc_insertion_point(field_list:ChampionFist.S_HallRoom.room_info)
  return room_info_;
}

// -------------------------------------------------------------------

// FriendInfo

// string player_name = 1;
inline void FriendInfo::clear_player_name() {
  player_name_.ClearToEmpty();
}
inline const std::string& FriendInfo::player_name() const {
  // @@protoc_insertion_point(field_get:ChampionFist.FriendInfo.player_name)
  return _internal_player_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FriendInfo::set_player_name(ArgT0&& arg0, ArgT... args) {
 
 player_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ChampionFist.FriendInfo.player_name)
}
inline std::string* FriendInfo::mutable_player_name() {
  std::string* _s = _internal_mutable_player_name();
  // @@protoc_insertion_point(field_mutable:ChampionFist.FriendInfo.player_name)
  return _s;
}
inline const std::string& FriendInfo::_internal_player_name() const {
  return player_name_.Get();
}
inline void FriendInfo::_internal_set_player_name(const std::string& value) {
  
  player_name_.Set(value, GetArenaForAllocation());
}
inline std::string* FriendInfo::_internal_mutable_player_name() {
  
  return player_name_.Mutable(GetArenaForAllocation());
}
inline std::string* FriendInfo::release_player_name() {
  // @@protoc_insertion_point(field_release:ChampionFist.FriendInfo.player_name)
  return player_name_.Release();
}
inline void FriendInfo::set_allocated_player_name(std::string* player_name) {
  if (player_name != nullptr) {
    
  } else {
    
  }
  player_name_.SetAllocated(player_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (player_name_.IsDefault()) {
    player_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ChampionFist.FriendInfo.player_name)
}

// int32 state = 2;
inline void FriendInfo::clear_state() {
  state_ = 0;
}
inline int32_t FriendInfo::_internal_state() const {
  return state_;
}
inline int32_t FriendInfo::state() const {
  // @@protoc_insertion_point(field_get:ChampionFist.FriendInfo.state)
  return _internal_state();
}
inline void FriendInfo::_internal_set_state(int32_t value) {
  
  state_ = value;
}
inline void FriendInfo::set_state(int32_t value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:ChampionFist.FriendInfo.state)
}

// -------------------------------------------------------------------

// S_Friend

// repeated .ChampionFist.FriendInfo friend_info = 1;
inline int S_Friend::_internal_friend_info_size() const {
  return friend_info_.size();
}
inline int S_Friend::friend_info_size() const {
  return _internal_friend_info_size();
}
inline void S_Friend::clear_friend_info() {
  friend_info_.Clear();
}
inline ::ChampionFist::FriendInfo* S_Friend::mutable_friend_info(int index) {
  // @@protoc_insertion_point(field_mutable:ChampionFist.S_Friend.friend_info)
  return friend_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ChampionFist::FriendInfo >*
S_Friend::mutable_friend_info() {
  // @@protoc_insertion_point(field_mutable_list:ChampionFist.S_Friend.friend_info)
  return &friend_info_;
}
inline const ::ChampionFist::FriendInfo& S_Friend::_internal_friend_info(int index) const {
  return friend_info_.Get(index);
}
inline const ::ChampionFist::FriendInfo& S_Friend::friend_info(int index) const {
  // @@protoc_insertion_point(field_get:ChampionFist.S_Friend.friend_info)
  return _internal_friend_info(index);
}
inline ::ChampionFist::FriendInfo* S_Friend::_internal_add_friend_info() {
  return friend_info_.Add();
}
inline ::ChampionFist::FriendInfo* S_Friend::add_friend_info() {
  ::ChampionFist::FriendInfo* _add = _internal_add_friend_info();
  // @@protoc_insertion_point(field_add:ChampionFist.S_Friend.friend_info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ChampionFist::FriendInfo >&
S_Friend::friend_info() const {
  // @@protoc_insertion_point(field_list:ChampionFist.S_Friend.friend_info)
  return friend_info_;
}

// -------------------------------------------------------------------

// S_FriendUpdate

// .ChampionFist.FriendInfo friend_info = 1;
inline bool S_FriendUpdate::_internal_has_friend_info() const {
  return this != internal_default_instance() && friend_info_ != nullptr;
}
inline bool S_FriendUpdate::has_friend_info() const {
  return _internal_has_friend_info();
}
inline void S_FriendUpdate::clear_friend_info() {
  if (GetArenaForAllocation() == nullptr && friend_info_ != nullptr) {
    delete friend_info_;
  }
  friend_info_ = nullptr;
}
inline const ::ChampionFist::FriendInfo& S_FriendUpdate::_internal_friend_info() const {
  const ::ChampionFist::FriendInfo* p = friend_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::ChampionFist::FriendInfo&>(
      ::ChampionFist::_FriendInfo_default_instance_);
}
inline const ::ChampionFist::FriendInfo& S_FriendUpdate::friend_info() const {
  // @@protoc_insertion_point(field_get:ChampionFist.S_FriendUpdate.friend_info)
  return _internal_friend_info();
}
inline void S_FriendUpdate::unsafe_arena_set_allocated_friend_info(
    ::ChampionFist::FriendInfo* friend_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(friend_info_);
  }
  friend_info_ = friend_info;
  if (friend_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ChampionFist.S_FriendUpdate.friend_info)
}
inline ::ChampionFist::FriendInfo* S_FriendUpdate::release_friend_info() {
  
  ::ChampionFist::FriendInfo* temp = friend_info_;
  friend_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ChampionFist::FriendInfo* S_FriendUpdate::unsafe_arena_release_friend_info() {
  // @@protoc_insertion_point(field_release:ChampionFist.S_FriendUpdate.friend_info)
  
  ::ChampionFist::FriendInfo* temp = friend_info_;
  friend_info_ = nullptr;
  return temp;
}
inline ::ChampionFist::FriendInfo* S_FriendUpdate::_internal_mutable_friend_info() {
  
  if (friend_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::ChampionFist::FriendInfo>(GetArenaForAllocation());
    friend_info_ = p;
  }
  return friend_info_;
}
inline ::ChampionFist::FriendInfo* S_FriendUpdate::mutable_friend_info() {
  ::ChampionFist::FriendInfo* _msg = _internal_mutable_friend_info();
  // @@protoc_insertion_point(field_mutable:ChampionFist.S_FriendUpdate.friend_info)
  return _msg;
}
inline void S_FriendUpdate::set_allocated_friend_info(::ChampionFist::FriendInfo* friend_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete friend_info_;
  }
  if (friend_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(friend_info);
    if (message_arena != submessage_arena) {
      friend_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, friend_info, submessage_arena);
    }
    
  } else {
    
  }
  friend_info_ = friend_info;
  // @@protoc_insertion_point(field_set_allocated:ChampionFist.S_FriendUpdate.friend_info)
}

// -------------------------------------------------------------------

// S_EnterRoom

// int32 seat_no = 1;
inline void S_EnterRoom::clear_seat_no() {
  seat_no_ = 0;
}
inline int32_t S_EnterRoom::_internal_seat_no() const {
  return seat_no_;
}
inline int32_t S_EnterRoom::seat_no() const {
  // @@protoc_insertion_point(field_get:ChampionFist.S_EnterRoom.seat_no)
  return _internal_seat_no();
}
inline void S_EnterRoom::_internal_set_seat_no(int32_t value) {
  
  seat_no_ = value;
}
inline void S_EnterRoom::set_seat_no(int32_t value) {
  _internal_set_seat_no(value);
  // @@protoc_insertion_point(field_set:ChampionFist.S_EnterRoom.seat_no)
}

// int32 state = 2;
inline void S_EnterRoom::clear_state() {
  state_ = 0;
}
inline int32_t S_EnterRoom::_internal_state() const {
  return state_;
}
inline int32_t S_EnterRoom::state() const {
  // @@protoc_insertion_point(field_get:ChampionFist.S_EnterRoom.state)
  return _internal_state();
}
inline void S_EnterRoom::_internal_set_state(int32_t value) {
  
  state_ = value;
}
inline void S_EnterRoom::set_state(int32_t value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:ChampionFist.S_EnterRoom.state)
}

// -------------------------------------------------------------------

// PlayerInfo

// string player_name = 1;
inline void PlayerInfo::clear_player_name() {
  player_name_.ClearToEmpty();
}
inline const std::string& PlayerInfo::player_name() const {
  // @@protoc_insertion_point(field_get:ChampionFist.PlayerInfo.player_name)
  return _internal_player_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PlayerInfo::set_player_name(ArgT0&& arg0, ArgT... args) {
 
 player_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ChampionFist.PlayerInfo.player_name)
}
inline std::string* PlayerInfo::mutable_player_name() {
  std::string* _s = _internal_mutable_player_name();
  // @@protoc_insertion_point(field_mutable:ChampionFist.PlayerInfo.player_name)
  return _s;
}
inline const std::string& PlayerInfo::_internal_player_name() const {
  return player_name_.Get();
}
inline void PlayerInfo::_internal_set_player_name(const std::string& value) {
  
  player_name_.Set(value, GetArenaForAllocation());
}
inline std::string* PlayerInfo::_internal_mutable_player_name() {
  
  return player_name_.Mutable(GetArenaForAllocation());
}
inline std::string* PlayerInfo::release_player_name() {
  // @@protoc_insertion_point(field_release:ChampionFist.PlayerInfo.player_name)
  return player_name_.Release();
}
inline void PlayerInfo::set_allocated_player_name(std::string* player_name) {
  if (player_name != nullptr) {
    
  } else {
    
  }
  player_name_.SetAllocated(player_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (player_name_.IsDefault()) {
    player_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ChampionFist.PlayerInfo.player_name)
}

// int32 char_type = 2;
inline void PlayerInfo::clear_char_type() {
  char_type_ = 0;
}
inline int32_t PlayerInfo::_internal_char_type() const {
  return char_type_;
}
inline int32_t PlayerInfo::char_type() const {
  // @@protoc_insertion_point(field_get:ChampionFist.PlayerInfo.char_type)
  return _internal_char_type();
}
inline void PlayerInfo::_internal_set_char_type(int32_t value) {
  
  char_type_ = value;
}
inline void PlayerInfo::set_char_type(int32_t value) {
  _internal_set_char_type(value);
  // @@protoc_insertion_point(field_set:ChampionFist.PlayerInfo.char_type)
}

// int32 ready = 3;
inline void PlayerInfo::clear_ready() {
  ready_ = 0;
}
inline int32_t PlayerInfo::_internal_ready() const {
  return ready_;
}
inline int32_t PlayerInfo::ready() const {
  // @@protoc_insertion_point(field_get:ChampionFist.PlayerInfo.ready)
  return _internal_ready();
}
inline void PlayerInfo::_internal_set_ready(int32_t value) {
  
  ready_ = value;
}
inline void PlayerInfo::set_ready(int32_t value) {
  _internal_set_ready(value);
  // @@protoc_insertion_point(field_set:ChampionFist.PlayerInfo.ready)
}

// int32 owner = 4;
inline void PlayerInfo::clear_owner() {
  owner_ = 0;
}
inline int32_t PlayerInfo::_internal_owner() const {
  return owner_;
}
inline int32_t PlayerInfo::owner() const {
  // @@protoc_insertion_point(field_get:ChampionFist.PlayerInfo.owner)
  return _internal_owner();
}
inline void PlayerInfo::_internal_set_owner(int32_t value) {
  
  owner_ = value;
}
inline void PlayerInfo::set_owner(int32_t value) {
  _internal_set_owner(value);
  // @@protoc_insertion_point(field_set:ChampionFist.PlayerInfo.owner)
}

// -------------------------------------------------------------------

// SeatInfo

// int32 empty = 1;
inline void SeatInfo::clear_empty() {
  empty_ = 0;
}
inline int32_t SeatInfo::_internal_empty() const {
  return empty_;
}
inline int32_t SeatInfo::empty() const {
  // @@protoc_insertion_point(field_get:ChampionFist.SeatInfo.empty)
  return _internal_empty();
}
inline void SeatInfo::_internal_set_empty(int32_t value) {
  
  empty_ = value;
}
inline void SeatInfo::set_empty(int32_t value) {
  _internal_set_empty(value);
  // @@protoc_insertion_point(field_set:ChampionFist.SeatInfo.empty)
}

// int32 seat_no = 2;
inline void SeatInfo::clear_seat_no() {
  seat_no_ = 0;
}
inline int32_t SeatInfo::_internal_seat_no() const {
  return seat_no_;
}
inline int32_t SeatInfo::seat_no() const {
  // @@protoc_insertion_point(field_get:ChampionFist.SeatInfo.seat_no)
  return _internal_seat_no();
}
inline void SeatInfo::_internal_set_seat_no(int32_t value) {
  
  seat_no_ = value;
}
inline void SeatInfo::set_seat_no(int32_t value) {
  _internal_set_seat_no(value);
  // @@protoc_insertion_point(field_set:ChampionFist.SeatInfo.seat_no)
}

// .ChampionFist.PlayerInfo player_info = 3;
inline bool SeatInfo::_internal_has_player_info() const {
  return this != internal_default_instance() && player_info_ != nullptr;
}
inline bool SeatInfo::has_player_info() const {
  return _internal_has_player_info();
}
inline void SeatInfo::clear_player_info() {
  if (GetArenaForAllocation() == nullptr && player_info_ != nullptr) {
    delete player_info_;
  }
  player_info_ = nullptr;
}
inline const ::ChampionFist::PlayerInfo& SeatInfo::_internal_player_info() const {
  const ::ChampionFist::PlayerInfo* p = player_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::ChampionFist::PlayerInfo&>(
      ::ChampionFist::_PlayerInfo_default_instance_);
}
inline const ::ChampionFist::PlayerInfo& SeatInfo::player_info() const {
  // @@protoc_insertion_point(field_get:ChampionFist.SeatInfo.player_info)
  return _internal_player_info();
}
inline void SeatInfo::unsafe_arena_set_allocated_player_info(
    ::ChampionFist::PlayerInfo* player_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(player_info_);
  }
  player_info_ = player_info;
  if (player_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ChampionFist.SeatInfo.player_info)
}
inline ::ChampionFist::PlayerInfo* SeatInfo::release_player_info() {
  
  ::ChampionFist::PlayerInfo* temp = player_info_;
  player_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ChampionFist::PlayerInfo* SeatInfo::unsafe_arena_release_player_info() {
  // @@protoc_insertion_point(field_release:ChampionFist.SeatInfo.player_info)
  
  ::ChampionFist::PlayerInfo* temp = player_info_;
  player_info_ = nullptr;
  return temp;
}
inline ::ChampionFist::PlayerInfo* SeatInfo::_internal_mutable_player_info() {
  
  if (player_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::ChampionFist::PlayerInfo>(GetArenaForAllocation());
    player_info_ = p;
  }
  return player_info_;
}
inline ::ChampionFist::PlayerInfo* SeatInfo::mutable_player_info() {
  ::ChampionFist::PlayerInfo* _msg = _internal_mutable_player_info();
  // @@protoc_insertion_point(field_mutable:ChampionFist.SeatInfo.player_info)
  return _msg;
}
inline void SeatInfo::set_allocated_player_info(::ChampionFist::PlayerInfo* player_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete player_info_;
  }
  if (player_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(player_info);
    if (message_arena != submessage_arena) {
      player_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, player_info, submessage_arena);
    }
    
  } else {
    
  }
  player_info_ = player_info;
  // @@protoc_insertion_point(field_set_allocated:ChampionFist.SeatInfo.player_info)
}

// -------------------------------------------------------------------

// S_RoomInfo

// repeated .ChampionFist.SeatInfo seat_info = 1;
inline int S_RoomInfo::_internal_seat_info_size() const {
  return seat_info_.size();
}
inline int S_RoomInfo::seat_info_size() const {
  return _internal_seat_info_size();
}
inline void S_RoomInfo::clear_seat_info() {
  seat_info_.Clear();
}
inline ::ChampionFist::SeatInfo* S_RoomInfo::mutable_seat_info(int index) {
  // @@protoc_insertion_point(field_mutable:ChampionFist.S_RoomInfo.seat_info)
  return seat_info_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ChampionFist::SeatInfo >*
S_RoomInfo::mutable_seat_info() {
  // @@protoc_insertion_point(field_mutable_list:ChampionFist.S_RoomInfo.seat_info)
  return &seat_info_;
}
inline const ::ChampionFist::SeatInfo& S_RoomInfo::_internal_seat_info(int index) const {
  return seat_info_.Get(index);
}
inline const ::ChampionFist::SeatInfo& S_RoomInfo::seat_info(int index) const {
  // @@protoc_insertion_point(field_get:ChampionFist.S_RoomInfo.seat_info)
  return _internal_seat_info(index);
}
inline ::ChampionFist::SeatInfo* S_RoomInfo::_internal_add_seat_info() {
  return seat_info_.Add();
}
inline ::ChampionFist::SeatInfo* S_RoomInfo::add_seat_info() {
  ::ChampionFist::SeatInfo* _add = _internal_add_seat_info();
  // @@protoc_insertion_point(field_add:ChampionFist.S_RoomInfo.seat_info)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::ChampionFist::SeatInfo >&
S_RoomInfo::seat_info() const {
  // @@protoc_insertion_point(field_list:ChampionFist.S_RoomInfo.seat_info)
  return seat_info_;
}

// -------------------------------------------------------------------

// S_ExitRoom

// int32 state = 1;
inline void S_ExitRoom::clear_state() {
  state_ = 0;
}
inline int32_t S_ExitRoom::_internal_state() const {
  return state_;
}
inline int32_t S_ExitRoom::state() const {
  // @@protoc_insertion_point(field_get:ChampionFist.S_ExitRoom.state)
  return _internal_state();
}
inline void S_ExitRoom::_internal_set_state(int32_t value) {
  
  state_ = value;
}
inline void S_ExitRoom::set_state(int32_t value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:ChampionFist.S_ExitRoom.state)
}

// -------------------------------------------------------------------

// S_UpdateRoom

// .ChampionFist.SeatInfo seat_info = 1;
inline bool S_UpdateRoom::_internal_has_seat_info() const {
  return this != internal_default_instance() && seat_info_ != nullptr;
}
inline bool S_UpdateRoom::has_seat_info() const {
  return _internal_has_seat_info();
}
inline void S_UpdateRoom::clear_seat_info() {
  if (GetArenaForAllocation() == nullptr && seat_info_ != nullptr) {
    delete seat_info_;
  }
  seat_info_ = nullptr;
}
inline const ::ChampionFist::SeatInfo& S_UpdateRoom::_internal_seat_info() const {
  const ::ChampionFist::SeatInfo* p = seat_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::ChampionFist::SeatInfo&>(
      ::ChampionFist::_SeatInfo_default_instance_);
}
inline const ::ChampionFist::SeatInfo& S_UpdateRoom::seat_info() const {
  // @@protoc_insertion_point(field_get:ChampionFist.S_UpdateRoom.seat_info)
  return _internal_seat_info();
}
inline void S_UpdateRoom::unsafe_arena_set_allocated_seat_info(
    ::ChampionFist::SeatInfo* seat_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(seat_info_);
  }
  seat_info_ = seat_info;
  if (seat_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ChampionFist.S_UpdateRoom.seat_info)
}
inline ::ChampionFist::SeatInfo* S_UpdateRoom::release_seat_info() {
  
  ::ChampionFist::SeatInfo* temp = seat_info_;
  seat_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ChampionFist::SeatInfo* S_UpdateRoom::unsafe_arena_release_seat_info() {
  // @@protoc_insertion_point(field_release:ChampionFist.S_UpdateRoom.seat_info)
  
  ::ChampionFist::SeatInfo* temp = seat_info_;
  seat_info_ = nullptr;
  return temp;
}
inline ::ChampionFist::SeatInfo* S_UpdateRoom::_internal_mutable_seat_info() {
  
  if (seat_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::ChampionFist::SeatInfo>(GetArenaForAllocation());
    seat_info_ = p;
  }
  return seat_info_;
}
inline ::ChampionFist::SeatInfo* S_UpdateRoom::mutable_seat_info() {
  ::ChampionFist::SeatInfo* _msg = _internal_mutable_seat_info();
  // @@protoc_insertion_point(field_mutable:ChampionFist.S_UpdateRoom.seat_info)
  return _msg;
}
inline void S_UpdateRoom::set_allocated_seat_info(::ChampionFist::SeatInfo* seat_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete seat_info_;
  }
  if (seat_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(seat_info);
    if (message_arena != submessage_arena) {
      seat_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, seat_info, submessage_arena);
    }
    
  } else {
    
  }
  seat_info_ = seat_info;
  // @@protoc_insertion_point(field_set_allocated:ChampionFist.S_UpdateRoom.seat_info)
}

// -------------------------------------------------------------------

// S_ModChar

// int32 state = 1;
inline void S_ModChar::clear_state() {
  state_ = 0;
}
inline int32_t S_ModChar::_internal_state() const {
  return state_;
}
inline int32_t S_ModChar::state() const {
  // @@protoc_insertion_point(field_get:ChampionFist.S_ModChar.state)
  return _internal_state();
}
inline void S_ModChar::_internal_set_state(int32_t value) {
  
  state_ = value;
}
inline void S_ModChar::set_state(int32_t value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:ChampionFist.S_ModChar.state)
}

// -------------------------------------------------------------------

// S_Ready

// int32 state = 1;
inline void S_Ready::clear_state() {
  state_ = 0;
}
inline int32_t S_Ready::_internal_state() const {
  return state_;
}
inline int32_t S_Ready::state() const {
  // @@protoc_insertion_point(field_get:ChampionFist.S_Ready.state)
  return _internal_state();
}
inline void S_Ready::_internal_set_state(int32_t value) {
  
  state_ = value;
}
inline void S_Ready::set_state(int32_t value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:ChampionFist.S_Ready.state)
}

// -------------------------------------------------------------------

// S_CancelReady

// int32 state = 1;
inline void S_CancelReady::clear_state() {
  state_ = 0;
}
inline int32_t S_CancelReady::_internal_state() const {
  return state_;
}
inline int32_t S_CancelReady::state() const {
  // @@protoc_insertion_point(field_get:ChampionFist.S_CancelReady.state)
  return _internal_state();
}
inline void S_CancelReady::_internal_set_state(int32_t value) {
  
  state_ = value;
}
inline void S_CancelReady::set_state(int32_t value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:ChampionFist.S_CancelReady.state)
}

// -------------------------------------------------------------------

// S_StartGame

// int32 state = 1;
inline void S_StartGame::clear_state() {
  state_ = 0;
}
inline int32_t S_StartGame::_internal_state() const {
  return state_;
}
inline int32_t S_StartGame::state() const {
  // @@protoc_insertion_point(field_get:ChampionFist.S_StartGame.state)
  return _internal_state();
}
inline void S_StartGame::_internal_set_state(int32_t value) {
  
  state_ = value;
}
inline void S_StartGame::set_state(int32_t value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:ChampionFist.S_StartGame.state)
}

// -------------------------------------------------------------------

// S_ExitLogin

// int32 state = 1;
inline void S_ExitLogin::clear_state() {
  state_ = 0;
}
inline int32_t S_ExitLogin::_internal_state() const {
  return state_;
}
inline int32_t S_ExitLogin::state() const {
  // @@protoc_insertion_point(field_get:ChampionFist.S_ExitLogin.state)
  return _internal_state();
}
inline void S_ExitLogin::_internal_set_state(int32_t value) {
  
  state_ = value;
}
inline void S_ExitLogin::set_state(int32_t value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:ChampionFist.S_ExitLogin.state)
}

// -------------------------------------------------------------------

// S_Quit

// int32 state = 1;
inline void S_Quit::clear_state() {
  state_ = 0;
}
inline int32_t S_Quit::_internal_state() const {
  return state_;
}
inline int32_t S_Quit::state() const {
  // @@protoc_insertion_point(field_get:ChampionFist.S_Quit.state)
  return _internal_state();
}
inline void S_Quit::_internal_set_state(int32_t value) {
  
  state_ = value;
}
inline void S_Quit::set_state(int32_t value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:ChampionFist.S_Quit.state)
}

// -------------------------------------------------------------------

// S_AddFriend

// int32 state = 1;
inline void S_AddFriend::clear_state() {
  state_ = 0;
}
inline int32_t S_AddFriend::_internal_state() const {
  return state_;
}
inline int32_t S_AddFriend::state() const {
  // @@protoc_insertion_point(field_get:ChampionFist.S_AddFriend.state)
  return _internal_state();
}
inline void S_AddFriend::_internal_set_state(int32_t value) {
  
  state_ = value;
}
inline void S_AddFriend::set_state(int32_t value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:ChampionFist.S_AddFriend.state)
}

// -------------------------------------------------------------------

// AddFriendInfo

// string friend_name = 1;
inline void AddFriendInfo::clear_friend_name() {
  friend_name_.ClearToEmpty();
}
inline const std::string& AddFriendInfo::friend_name() const {
  // @@protoc_insertion_point(field_get:ChampionFist.AddFriendInfo.friend_name)
  return _internal_friend_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddFriendInfo::set_friend_name(ArgT0&& arg0, ArgT... args) {
 
 friend_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:ChampionFist.AddFriendInfo.friend_name)
}
inline std::string* AddFriendInfo::mutable_friend_name() {
  std::string* _s = _internal_mutable_friend_name();
  // @@protoc_insertion_point(field_mutable:ChampionFist.AddFriendInfo.friend_name)
  return _s;
}
inline const std::string& AddFriendInfo::_internal_friend_name() const {
  return friend_name_.Get();
}
inline void AddFriendInfo::_internal_set_friend_name(const std::string& value) {
  
  friend_name_.Set(value, GetArenaForAllocation());
}
inline std::string* AddFriendInfo::_internal_mutable_friend_name() {
  
  return friend_name_.Mutable(GetArenaForAllocation());
}
inline std::string* AddFriendInfo::release_friend_name() {
  // @@protoc_insertion_point(field_release:ChampionFist.AddFriendInfo.friend_name)
  return friend_name_.Release();
}
inline void AddFriendInfo::set_allocated_friend_name(std::string* friend_name) {
  if (friend_name != nullptr) {
    
  } else {
    
  }
  friend_name_.SetAllocated(friend_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (friend_name_.IsDefault()) {
    friend_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:ChampionFist.AddFriendInfo.friend_name)
}

// -------------------------------------------------------------------

// S_OtherAddFriend

// .ChampionFist.AddFriendInfo friend_info = 1;
inline bool S_OtherAddFriend::_internal_has_friend_info() const {
  return this != internal_default_instance() && friend_info_ != nullptr;
}
inline bool S_OtherAddFriend::has_friend_info() const {
  return _internal_has_friend_info();
}
inline void S_OtherAddFriend::clear_friend_info() {
  if (GetArenaForAllocation() == nullptr && friend_info_ != nullptr) {
    delete friend_info_;
  }
  friend_info_ = nullptr;
}
inline const ::ChampionFist::AddFriendInfo& S_OtherAddFriend::_internal_friend_info() const {
  const ::ChampionFist::AddFriendInfo* p = friend_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::ChampionFist::AddFriendInfo&>(
      ::ChampionFist::_AddFriendInfo_default_instance_);
}
inline const ::ChampionFist::AddFriendInfo& S_OtherAddFriend::friend_info() const {
  // @@protoc_insertion_point(field_get:ChampionFist.S_OtherAddFriend.friend_info)
  return _internal_friend_info();
}
inline void S_OtherAddFriend::unsafe_arena_set_allocated_friend_info(
    ::ChampionFist::AddFriendInfo* friend_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(friend_info_);
  }
  friend_info_ = friend_info;
  if (friend_info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:ChampionFist.S_OtherAddFriend.friend_info)
}
inline ::ChampionFist::AddFriendInfo* S_OtherAddFriend::release_friend_info() {
  
  ::ChampionFist::AddFriendInfo* temp = friend_info_;
  friend_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::ChampionFist::AddFriendInfo* S_OtherAddFriend::unsafe_arena_release_friend_info() {
  // @@protoc_insertion_point(field_release:ChampionFist.S_OtherAddFriend.friend_info)
  
  ::ChampionFist::AddFriendInfo* temp = friend_info_;
  friend_info_ = nullptr;
  return temp;
}
inline ::ChampionFist::AddFriendInfo* S_OtherAddFriend::_internal_mutable_friend_info() {
  
  if (friend_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::ChampionFist::AddFriendInfo>(GetArenaForAllocation());
    friend_info_ = p;
  }
  return friend_info_;
}
inline ::ChampionFist::AddFriendInfo* S_OtherAddFriend::mutable_friend_info() {
  ::ChampionFist::AddFriendInfo* _msg = _internal_mutable_friend_info();
  // @@protoc_insertion_point(field_mutable:ChampionFist.S_OtherAddFriend.friend_info)
  return _msg;
}
inline void S_OtherAddFriend::set_allocated_friend_info(::ChampionFist::AddFriendInfo* friend_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete friend_info_;
  }
  if (friend_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(friend_info);
    if (message_arena != submessage_arena) {
      friend_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, friend_info, submessage_arena);
    }
    
  } else {
    
  }
  friend_info_ = friend_info;
  // @@protoc_insertion_point(field_set_allocated:ChampionFist.S_OtherAddFriend.friend_info)
}

// -------------------------------------------------------------------

// S_CreateRoom

// int32 state = 1;
inline void S_CreateRoom::clear_state() {
  state_ = 0;
}
inline int32_t S_CreateRoom::_internal_state() const {
  return state_;
}
inline int32_t S_CreateRoom::state() const {
  // @@protoc_insertion_point(field_get:ChampionFist.S_CreateRoom.state)
  return _internal_state();
}
inline void S_CreateRoom::_internal_set_state(int32_t value) {
  
  state_ = value;
}
inline void S_CreateRoom::set_state(int32_t value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:ChampionFist.S_CreateRoom.state)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ChampionFist

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::ChampionFist::ServerCommandType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ChampionFist::ServerCommandType>() {
  return ::ChampionFist::ServerCommandType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_ServerToClient_2eproto
